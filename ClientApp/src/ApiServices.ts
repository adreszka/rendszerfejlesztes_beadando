//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginUser | undefined): Promise<UserRole> {
        let url_ = this.baseUrl + "/Auth/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<UserRole> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRole.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserRole>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addNewComponent(body: ComponentModel | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/Component/AddNewComponent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddNewComponent(_response);
        });
    }

    protected processAddNewComponent(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateComponentPrice(body: ComponentModel | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/Component/UpdateComponentPrice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateComponentPrice(_response);
        });
    }

    protected processUpdateComponentPrice(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Promise<ComponentModel[]> {
        let url_ = this.baseUrl + "/Component/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<ComponentModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComponentModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ComponentModel[]>(null as any);
    }

    /**
     * @return Success
     */
    getAvailableComponent(componentName: string): Promise<AvailableComponent> {
        let url_ = this.baseUrl + "/Component/GetAvailableComponent/{componentName}";
        if (componentName === undefined || componentName === null)
            throw new Error("The parameter 'componentName' must be defined.");
        url_ = url_.replace("{componentName}", encodeURIComponent("" + componentName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAvailableComponent(_response);
        });
    }

    protected processGetAvailableComponent(response: Response): Promise<AvailableComponent> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AvailableComponent.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AvailableComponent>(null as any);
    }

    /**
     * @return Success
     */
    getMissingComponents(): Promise<StoreComponent[]> {
        let url_ = this.baseUrl + "/Component/GetMissingComponents";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMissingComponents(_response);
        });
    }

    protected processGetMissingComponents(response: Response): Promise<StoreComponent[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StoreComponent.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StoreComponent[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addNewProject(body: NewProject | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/Project/AddNewProject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddNewProject(_response);
        });
    }

    protected processAddNewProject(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addWorkTimeAndFee(body: WorkTimeAndFee | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/Project/AddWorkTimeAndFee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddWorkTimeAndFee(_response);
        });
    }

    protected processAddWorkTimeAndFee(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addComponentToProject(body: AddComponentToProject | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/Project/AddComponentToProject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddComponentToProject(_response);
        });
    }

    protected processAddComponentToProject(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    getProjects(): Promise<Project[]> {
        let url_ = this.baseUrl + "/Project/GetProjects";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProjects(_response);
        });
    }

    protected processGetProjects(response: Response): Promise<Project[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Project.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Project[]>(null as any);
    }

    /**
     * @return Success
     */
    getProjectComponents(location: string): Promise<StoreComponent[]> {
        let url_ = this.baseUrl + "/Project/GetProjectComponents/{location}";
        if (location === undefined || location === null)
            throw new Error("The parameter 'location' must be defined.");
        url_ = url_.replace("{location}", encodeURIComponent("" + location));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProjectComponents(_response);
        });
    }

    protected processGetProjectComponents(response: Response): Promise<StoreComponent[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StoreComponent.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StoreComponent[]>(null as any);
    }

    /**
     * @return Success
     */
    getProjectsWithStatus(location: string): Promise<ProjectStatus> {
        let url_ = this.baseUrl + "/Project/GetProjectsWithStatus/{location}";
        if (location === undefined || location === null)
            throw new Error("The parameter 'location' must be defined.");
        url_ = url_.replace("{location}", encodeURIComponent("" + location));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProjectsWithStatus(_response);
        });
    }

    protected processGetProjectsWithStatus(response: Response): Promise<ProjectStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectStatus>(null as any);
    }

    /**
     * @return Success
     */
    priceCalculation(location: string): Promise<boolean> {
        let url_ = this.baseUrl + "/Project/PriceCalculation/{location}";
        if (location === undefined || location === null)
            throw new Error("The parameter 'location' must be defined.");
        url_ = url_.replace("{location}", encodeURIComponent("" + location));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPriceCalculation(_response);
        });
    }

    protected processPriceCalculation(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    getProjectsComponentsInformation(): Promise<MissingComponents[]> {
        let url_ = this.baseUrl + "/Project/GetProjectsComponentsInformation";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProjectsComponentsInformation(_response);
        });
    }

    protected processGetProjectsComponentsInformation(response: Response): Promise<MissingComponents[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MissingComponents.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MissingComponents[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    closeProject(body: ProjectClose | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/Project/CloseProject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCloseProject(_response);
        });
    }

    protected processCloseProject(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    listProject(location: string): Promise<AllInformationAboutTheProject> {
        let url_ = this.baseUrl + "/Project/ListProject/{location}";
        if (location === undefined || location === null)
            throw new Error("The parameter 'location' must be defined.");
        url_ = url_.replace("{location}", encodeURIComponent("" + location));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListProject(_response);
        });
    }

    protected processListProject(response: Response): Promise<AllInformationAboutTheProject> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AllInformationAboutTheProject.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AllInformationAboutTheProject>(null as any);
    }

    /**
     * @return Success
     */
    getMissingProjectComponents(location: string): Promise<StoreComponent[]> {
        let url_ = this.baseUrl + "/Project/GetMissingProjectComponents/{location}";
        if (location === undefined || location === null)
            throw new Error("The parameter 'location' must be defined.");
        url_ = url_.replace("{location}", encodeURIComponent("" + location));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMissingProjectComponents(_response);
        });
    }

    protected processGetMissingProjectComponents(response: Response): Promise<StoreComponent[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StoreComponent.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StoreComponent[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addComponentToProjectManual(body: AddComponentToProjectManually | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/Project/AddComponentToProjectManual";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddComponentToProjectManual(_response);
        });
    }

    protected processAddComponentToProjectManual(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    storage(body: StoreComponent | undefined): Promise<number> {
        let url_ = this.baseUrl + "/Storage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStorage(_response);
        });
    }

    protected processStorage(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @return Success
     */
    storageAll(componentName: string): Promise<StorageModel[]> {
        let url_ = this.baseUrl + "/Storage/{componentName}";
        if (componentName === undefined || componentName === null)
            throw new Error("The parameter 'componentName' must be defined.");
        url_ = url_.replace("{componentName}", encodeURIComponent("" + componentName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStorageAll(_response);
        });
    }

    protected processStorageAll(response: Response): Promise<StorageModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StorageModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StorageModel[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    user(body: User | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/User";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUser(_response);
        });
    }

    protected processUser(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    weatherForecast(): Promise<WeatherForecast[]> {
        let url_ = this.baseUrl + "/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWeatherForecast(_response);
        });
    }

    protected processWeatherForecast(response: Response): Promise<WeatherForecast[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WeatherForecast[]>(null as any);
    }
}

export class AddComponentToProject implements IAddComponentToProject {
    location?: string | undefined;
    name?: string | undefined;
    quantity?: number;

    constructor(data?: IAddComponentToProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.location = _data["location"];
            this.name = _data["name"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): AddComponentToProject {
        data = typeof data === 'object' ? data : {};
        let result = new AddComponentToProject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location"] = this.location;
        data["name"] = this.name;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IAddComponentToProject {
    location?: string | undefined;
    name?: string | undefined;
    quantity?: number;
}

export class AddComponentToProjectManually implements IAddComponentToProjectManually {
    addComponentToProject?: AddComponentToProject;
    storageLocation?: StorageLocation;

    constructor(data?: IAddComponentToProjectManually) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addComponentToProject = _data["addComponentToProject"] ? AddComponentToProject.fromJS(_data["addComponentToProject"]) : <any>undefined;
            this.storageLocation = _data["storageLocation"] ? StorageLocation.fromJS(_data["storageLocation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AddComponentToProjectManually {
        data = typeof data === 'object' ? data : {};
        let result = new AddComponentToProjectManually();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addComponentToProject"] = this.addComponentToProject ? this.addComponentToProject.toJSON() : <any>undefined;
        data["storageLocation"] = this.storageLocation ? this.storageLocation.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAddComponentToProjectManually {
    addComponentToProject?: AddComponentToProject;
    storageLocation?: StorageLocation;
}

export class AllInformationAboutTheProject implements IAllInformationAboutTheProject {
    statusName?: string | undefined;
    project?: ProjectModel;
    missingCompsFromProjects?: StoreComponent[] | undefined;
    reservedComponents?: StoreComponent[] | undefined;
    customer?: CustomerModel;
    projectComponents?: PathData[] | undefined;

    constructor(data?: IAllInformationAboutTheProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusName = _data["statusName"];
            this.project = _data["project"] ? ProjectModel.fromJS(_data["project"]) : <any>undefined;
            if (Array.isArray(_data["missingCompsFromProjects"])) {
                this.missingCompsFromProjects = [] as any;
                for (let item of _data["missingCompsFromProjects"])
                    this.missingCompsFromProjects!.push(StoreComponent.fromJS(item));
            }
            if (Array.isArray(_data["reservedComponents"])) {
                this.reservedComponents = [] as any;
                for (let item of _data["reservedComponents"])
                    this.reservedComponents!.push(StoreComponent.fromJS(item));
            }
            this.customer = _data["customer"] ? CustomerModel.fromJS(_data["customer"]) : <any>undefined;
            if (Array.isArray(_data["projectComponents"])) {
                this.projectComponents = [] as any;
                for (let item of _data["projectComponents"])
                    this.projectComponents!.push(PathData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AllInformationAboutTheProject {
        data = typeof data === 'object' ? data : {};
        let result = new AllInformationAboutTheProject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusName"] = this.statusName;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        if (Array.isArray(this.missingCompsFromProjects)) {
            data["missingCompsFromProjects"] = [];
            for (let item of this.missingCompsFromProjects)
                data["missingCompsFromProjects"].push(item.toJSON());
        }
        if (Array.isArray(this.reservedComponents)) {
            data["reservedComponents"] = [];
            for (let item of this.reservedComponents)
                data["reservedComponents"].push(item.toJSON());
        }
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        if (Array.isArray(this.projectComponents)) {
            data["projectComponents"] = [];
            for (let item of this.projectComponents)
                data["projectComponents"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAllInformationAboutTheProject {
    statusName?: string | undefined;
    project?: ProjectModel;
    missingCompsFromProjects?: StoreComponent[] | undefined;
    reservedComponents?: StoreComponent[] | undefined;
    customer?: CustomerModel;
    projectComponents?: PathData[] | undefined;
}

export class AvailableComponent implements IAvailableComponent {
    price?: number;
    availableQuantity?: number;

    constructor(data?: IAvailableComponent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.price = _data["price"];
            this.availableQuantity = _data["availableQuantity"];
        }
    }

    static fromJS(data: any): AvailableComponent {
        data = typeof data === 'object' ? data : {};
        let result = new AvailableComponent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["price"] = this.price;
        data["availableQuantity"] = this.availableQuantity;
        return data;
    }
}

export interface IAvailableComponent {
    price?: number;
    availableQuantity?: number;
}

export class ComponentModel implements IComponentModel {
    name?: string | undefined;
    price?: number;
    maxCapacity?: number;

    constructor(data?: IComponentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.price = _data["price"];
            this.maxCapacity = _data["maxCapacity"];
        }
    }

    static fromJS(data: any): ComponentModel {
        data = typeof data === 'object' ? data : {};
        let result = new ComponentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["price"] = this.price;
        data["maxCapacity"] = this.maxCapacity;
        return data;
    }
}

export interface IComponentModel {
    name?: string | undefined;
    price?: number;
    maxCapacity?: number;
}

export class Customer implements ICustomer {
    id?: number;
    name?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    taxNumber?: string | undefined;

    constructor(data?: ICustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.taxNumber = _data["taxNumber"];
        }
    }

    static fromJS(data: any): Customer {
        data = typeof data === 'object' ? data : {};
        let result = new Customer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["taxNumber"] = this.taxNumber;
        return data;
    }
}

export interface ICustomer {
    id?: number;
    name?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    taxNumber?: string | undefined;
}

export class CustomerModel implements ICustomerModel {
    name?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    taxNumber?: string | undefined;

    constructor(data?: ICustomerModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.taxNumber = _data["taxNumber"];
        }
    }

    static fromJS(data: any): CustomerModel {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["taxNumber"] = this.taxNumber;
        return data;
    }
}

export interface ICustomerModel {
    name?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    taxNumber?: string | undefined;
}

export class LoginUser implements ILoginUser {
    username?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginUser {
        data = typeof data === 'object' ? data : {};
        let result = new LoginUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginUser {
    username?: string | undefined;
    password?: string | undefined;
}

export class MissingComponents implements IMissingComponents {
    location?: string | undefined;
    missingCompsFromProjects?: StoreComponent[] | undefined;
    reservedComponents?: StoreComponent[] | undefined;

    constructor(data?: IMissingComponents) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.location = _data["location"];
            if (Array.isArray(_data["missingCompsFromProjects"])) {
                this.missingCompsFromProjects = [] as any;
                for (let item of _data["missingCompsFromProjects"])
                    this.missingCompsFromProjects!.push(StoreComponent.fromJS(item));
            }
            if (Array.isArray(_data["reservedComponents"])) {
                this.reservedComponents = [] as any;
                for (let item of _data["reservedComponents"])
                    this.reservedComponents!.push(StoreComponent.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MissingComponents {
        data = typeof data === 'object' ? data : {};
        let result = new MissingComponents();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location"] = this.location;
        if (Array.isArray(this.missingCompsFromProjects)) {
            data["missingCompsFromProjects"] = [];
            for (let item of this.missingCompsFromProjects)
                data["missingCompsFromProjects"].push(item.toJSON());
        }
        if (Array.isArray(this.reservedComponents)) {
            data["reservedComponents"] = [];
            for (let item of this.reservedComponents)
                data["reservedComponents"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMissingComponents {
    location?: string | undefined;
    missingCompsFromProjects?: StoreComponent[] | undefined;
    reservedComponents?: StoreComponent[] | undefined;
}

export class NewProject implements INewProject {
    name?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    taxNumber?: string | undefined;
    location?: string | undefined;
    description?: string | undefined;

    constructor(data?: INewProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.taxNumber = _data["taxNumber"];
            this.location = _data["location"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): NewProject {
        data = typeof data === 'object' ? data : {};
        let result = new NewProject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["taxNumber"] = this.taxNumber;
        data["location"] = this.location;
        data["description"] = this.description;
        return data;
    }
}

export interface INewProject {
    name?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    taxNumber?: string | undefined;
    location?: string | undefined;
    description?: string | undefined;
}

export class PathData implements IPathData {
    componentName?: string | undefined;
    location?: StorageLocation;
    quantity?: number;

    constructor(data?: IPathData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.componentName = _data["componentName"];
            this.location = _data["location"] ? StorageLocation.fromJS(_data["location"]) : <any>undefined;
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): PathData {
        data = typeof data === 'object' ? data : {};
        let result = new PathData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["componentName"] = this.componentName;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IPathData {
    componentName?: string | undefined;
    location?: StorageLocation;
    quantity?: number;
}

export class Project implements IProject {
    id?: number;
    location?: string | undefined;
    description?: string | undefined;
    customerId?: number;
    customer?: Customer;
    workTime?: number | undefined;
    fee?: number | undefined;
    componentsPrices?: number | undefined;

    constructor(data?: IProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.location = _data["location"];
            this.description = _data["description"];
            this.customerId = _data["customerId"];
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
            this.workTime = _data["workTime"];
            this.fee = _data["fee"];
            this.componentsPrices = _data["componentsPrices"];
        }
    }

    static fromJS(data: any): Project {
        data = typeof data === 'object' ? data : {};
        let result = new Project();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["location"] = this.location;
        data["description"] = this.description;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["workTime"] = this.workTime;
        data["fee"] = this.fee;
        data["componentsPrices"] = this.componentsPrices;
        return data;
    }
}

export interface IProject {
    id?: number;
    location?: string | undefined;
    description?: string | undefined;
    customerId?: number;
    customer?: Customer;
    workTime?: number | undefined;
    fee?: number | undefined;
    componentsPrices?: number | undefined;
}

export class ProjectClose implements IProjectClose {
    location?: string | undefined;
    projectFinished?: boolean;

    constructor(data?: IProjectClose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.location = _data["location"];
            this.projectFinished = _data["projectFinished"];
        }
    }

    static fromJS(data: any): ProjectClose {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectClose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location"] = this.location;
        data["projectFinished"] = this.projectFinished;
        return data;
    }
}

export interface IProjectClose {
    location?: string | undefined;
    projectFinished?: boolean;
}

export class ProjectModel implements IProjectModel {
    location?: string | undefined;
    description?: string | undefined;
    workTime?: number | undefined;
    fee?: number | undefined;
    componentPrices?: number | undefined;

    constructor(data?: IProjectModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.location = _data["location"];
            this.description = _data["description"];
            this.workTime = _data["workTime"];
            this.fee = _data["fee"];
            this.componentPrices = _data["componentPrices"];
        }
    }

    static fromJS(data: any): ProjectModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location"] = this.location;
        data["description"] = this.description;
        data["workTime"] = this.workTime;
        data["fee"] = this.fee;
        data["componentPrices"] = this.componentPrices;
        return data;
    }
}

export interface IProjectModel {
    location?: string | undefined;
    description?: string | undefined;
    workTime?: number | undefined;
    fee?: number | undefined;
    componentPrices?: number | undefined;
}

export class ProjectStatus implements IProjectStatus {
    statusName?: string | undefined;

    constructor(data?: IProjectStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusName = _data["statusName"];
        }
    }

    static fromJS(data: any): ProjectStatus {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusName"] = this.statusName;
        return data;
    }
}

export interface IProjectStatus {
    statusName?: string | undefined;
}

export class StorageLocation implements IStorageLocation {
    row?: number;
    columnn?: number;
    level?: number;

    constructor(data?: IStorageLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.row = _data["row"];
            this.columnn = _data["columnn"];
            this.level = _data["level"];
        }
    }

    static fromJS(data: any): StorageLocation {
        data = typeof data === 'object' ? data : {};
        let result = new StorageLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["row"] = this.row;
        data["columnn"] = this.columnn;
        data["level"] = this.level;
        return data;
    }
}

export interface IStorageLocation {
    row?: number;
    columnn?: number;
    level?: number;
}

export class StorageModel implements IStorageModel {
    row?: number;
    columnn?: number;
    level?: number;
    freeComponent?: StoreComponent;

    constructor(data?: IStorageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.row = _data["row"];
            this.columnn = _data["columnn"];
            this.level = _data["level"];
            this.freeComponent = _data["freeComponent"] ? StoreComponent.fromJS(_data["freeComponent"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StorageModel {
        data = typeof data === 'object' ? data : {};
        let result = new StorageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["row"] = this.row;
        data["columnn"] = this.columnn;
        data["level"] = this.level;
        data["freeComponent"] = this.freeComponent ? this.freeComponent.toJSON() : <any>undefined;
        return data;
    }
}

export interface IStorageModel {
    row?: number;
    columnn?: number;
    level?: number;
    freeComponent?: StoreComponent;
}

export class StoreComponent implements IStoreComponent {
    name?: string | undefined;
    quantity?: number;

    constructor(data?: IStoreComponent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): StoreComponent {
        data = typeof data === 'object' ? data : {};
        let result = new StoreComponent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IStoreComponent {
    name?: string | undefined;
    quantity?: number;
}

export class User implements IUser {
    userName?: string | undefined;
    password?: string | undefined;
    role?: string | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["role"] = this.role;
        return data;
    }
}

export interface IUser {
    userName?: string | undefined;
    password?: string | undefined;
    role?: string | undefined;
}

export class UserRole implements IUserRole {
    role?: string | undefined;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role;
        return data;
    }
}

export interface IUserRole {
    role?: string | undefined;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    readonly temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            (<any>this).temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

export class WorkTimeAndFee implements IWorkTimeAndFee {
    worktime?: number;
    fee?: number;
    location?: string | undefined;

    constructor(data?: IWorkTimeAndFee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.worktime = _data["worktime"];
            this.fee = _data["fee"];
            this.location = _data["location"];
        }
    }

    static fromJS(data: any): WorkTimeAndFee {
        data = typeof data === 'object' ? data : {};
        let result = new WorkTimeAndFee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["worktime"] = this.worktime;
        data["fee"] = this.fee;
        data["location"] = this.location;
        return data;
    }
}

export interface IWorkTimeAndFee {
    worktime?: number;
    fee?: number;
    location?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}